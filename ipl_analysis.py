# -*- coding: utf-8 -*-
"""IPL analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1dt6yHIW4rOe5yE9nilUpalzQyD0H0V_8

# Importing Libraries & Merging DataSet
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from sklearn.preprocessing import LabelEncoder

from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.metrics import accuracy_score, classification_report

balls = pd.read_csv(r"C:\Users\KIIT\Desktop\Task\Projects\IPL Project\deliveries.csv")
matches = pd.read_csv(r"C:\Users\KIIT\Desktop\Task\Projects\IPL Project\matches.csv")

# Merging match info into balls dataset using 'match_id'

df = balls.merge(matches,
    left_on='match_id',
    right_on='id',
    how='left'
)



"""# Data Cleaning & Preprocessing

## Handling missing Values
"""

df.isnull().sum()

df.isnull().sum()[df.isnull().sum() > 0]

"""### extras_type"""

df['extras_type'].fillna('None', inplace=True)  # Replace missing extra type with "None"

"""### player_dismissed"""

df['player_dismissed'].fillna('No Dismissal', inplace=True)  # Indicate no player was dismissed

"""### dismissal_kind"""

df['dismissal_kind'].fillna('Not Out', inplace=True)  # Mark missing dismissals as "Not Out"

"""### fielder"""

df['fielder'].fillna('None', inplace=True)  # Set missing fielder values to "None"

"""### winner"""

df['winner'].fillna('No Result', inplace=True)  # Assign "No Result" to matches with no winner

"""### method"""

df['method'].fillna('Normal', inplace=True)  # Assume DLS did not affect the match

missing_winners = matches[matches['winner'].isnull()]  # Identify matches with missing winners
missing_winners

matches.loc[matches['result'] == 'no result', 'winner'] = matches['winner'].fillna('No Winner')  # Explicitly mark abandoned matches

df.head()

df.isnull().sum()[df.isnull().sum() > 0]

"""### city

"""

venue_city_map = df[['venue', 'city']].dropna().drop_duplicates().set_index('venue')['city'].to_dict()
venue_of_null_cities=df[df['city'].isnull()][['venue','season','city','match_id']]
venue_of_null_cities['venue'].value_counts()

#manually fixing the cities name
venue_city_map.update({
    'Dubai International Cricket Stadium': 'Dubai',
    'Sharjah Cricket Stadium': 'Sharjah'
})

df['city'] = df.apply(lambda x: venue_city_map.get(x['venue'], x['city']), axis=1)

"""### player of match"""



missing_pom_matches = df[df['player_of_match'].isnull()]['match_id'].unique()
print(len(missing_pom_matches), "matches have no player of the match.")  # Number of matches with missing player of the match
missing_pom_matches   # index

df[df['match_id'].isin(missing_pom_matches)][['match_id','player_of_match', 'result', 'winner', 'method']].drop_duplicates()

df.loc[df['match_id'].isin(missing_pom_matches) & (df['result'] == 'no result'), 'player_of_match'] = 'No Player'  # Assigning "No Player" to matches with no winner

missing_pom_matches_after_fixing = df[df['player_of_match']=='No Player']['match_id'].unique()
df[df['match_id'].isin(missing_pom_matches_after_fixing)][['match_id','player_of_match', 'result', 'winner', 'method']].drop_duplicates()



"""### result margin"""

missing_result_margin_matches = df[df['result_margin'].isnull()]['match_id'].unique()
print(missing_result_margin_matches)

matches[matches['id'].isin(missing_result_margin_matches)][['id', 'result', 'result_margin', 'winner']]

df[df['result_margin'].isnull()]['result'].value_counts()

df['result_margin'].fillna(df['result'].apply(lambda x: 'Not Applicable' if x in ['tie', 'no result'] else x),inplace=True) #Filled Missing Result Margins Based on Match Result

df[df['result_margin'].isnull()]['result'].value_counts()



"""### target runs & overs"""

df[df['target_runs'].isnull()][['match_id', 'result', 'winner']]['result'].value_counts()

df['target_runs'].fillna(-1, inplace=True)
df['target_overs'].fillna(-1, inplace=True)

df.isnull().sum()[df.isnull().sum() > 0]



"""## Feature Engineering"""

# Mark legal deliveries (assuming 'wides' and 'noballs' indicate extras)
df['is_legal'] = df['extras_type'].apply(lambda x: x not in ['wides', 'noballs'])

# Compute the cumulative count of legal balls per match, inning, and over
df['legal_ball'] = df.apply(lambda x: x['ball'] if x['extras_type'] not in ['wides', 'noballs'] else None, axis=1)
df['legal_ball'] = df['legal_ball'].fillna(method='ffill').astype(int)  # Fill missing legal balls
df['legal_ball'] = df.groupby(['match_id', 'inning', 'over'])['legal_ball'].rank(method="dense").astype(int)

# Create the adjusted over_ball feature
df['all_balls_over_ball'] = df['over'] + (df['ball'] / 10)
df['adjusted_over_ball'] = df['over'] + (df['legal_ball'] / 10)

"""is_legal:delivery is legal or not

legal_ball:count of legal balls per over.

adjusted_over_ball:combined over-ball representation using only legal deliveries.
"""

# Assigning Match Numbers for Season and Overall Rankings
# Sort by season and date to ensure correct match order
df['match_number_of_that_season'] = df.groupby('season')['match_id'].rank(method='dense').astype(int)
df['matches_in_that_season'] = df['season'].map(df.groupby('season')['match_id'].nunique())
df['match_number_in_total'] = df['match_id'].rank(method='dense').astype(int)

df.groupby('season')['match_number_of_that_season'].max()
df.groupby('season')['matches_in_that_season'].first()
df[['season', 'match_id', 'match_number_of_that_season', 'match_number_in_total', 'matches_in_that_season']].drop_duplicates().sort_values(by=['season', 'match_number_of_that_season'])

"""## Encoding"""

# Convert categorical features to numerical
label_cols = ['batting_team', 'bowling_team', 'toss_winner', 'winner', 'venue', 'season']
encoder = LabelEncoder()

for col in label_cols:
    df[col] = encoder.fit_transform(df[col])

"""# Model-Random Forest"""

df['toss_win'] = (df['toss_winner'] == df['batting_team']).astype(int)

# Selecting Features & Target for the model
features = df[['batting_team', 'bowling_team', 'toss_win', 'venue', 'season']]
target = df['winner']

X_train, X_test, y_train, y_test = train_test_split(features, target, test_size=0.2, random_state=42, stratify=target)

RanFo = RandomForestClassifier(n_estimators=200, max_depth=10, min_samples_split=5, random_state=42)
RanFo.fit(X_train, y_train)

y_pred = RanFo.predict(X_test)
accuracy = accuracy_score(y_test, y_pred)

print(f"üéØ Match Winner Prediction Accuracy: {accuracy * 100:.2f}%")
print(classification_report(y_test, y_pred))

cv_scores = cross_val_score(RanFo, X_train, y_train, cv=5, scoring='accuracy')
print(f"üìä Cross-Validation Accuracy: {np.mean(cv_scores) * 100:.2f}%")

importances = pd.Series(RanFo.feature_importances_, index=X_train.columns).sort_values(ascending=False)
print("\nüîç Feature Importance:\n", importances)

"""# Deployment"""

import joblib
joblib.dump(RanFo, 'ipl_model.pkl')


import streamlit as st
import joblib
import pandas as pd

# Load the trained model
model = joblib.load("ipl_model.pkl")

# Streamlit UI
st.title("üèè IPL Match Prediction")

st.write("Enter match details below to predict the outcome.")

# User Inputs
batting_team = st.selectbox("Select Batting Team", ["MI", "CSK", "RCB", "KKR", "SRH", "RR", "DC", "PBKS", "GT", "LSG"])
bowling_team = st.selectbox("Select Bowling Team", ["MI", "CSK", "RCB", "KKR", "SRH", "RR", "DC", "PBKS", "GT", "LSG"])
venue = st.text_input("Enter Venue (e.g., Wankhede Stadium)")
overs = st.number_input("Overs Completed", min_value=0, max_value=20, value=10)
runs = st.number_input("Current Runs", min_value=0)
wickets = st.number_input("Wickets Fallen", min_value=0, max_value=10)

# Prepare input for the model
if st.button("Predict"):
    input_data = pd.DataFrame({
        "batting_team": [batting_team],
        "bowling_team": [bowling_team],
        "venue": [venue],
        "overs": [overs],
        "runs": [runs],
        "wickets": [wickets]
    })

    # Make prediction
    prediction = model.predict(input_data)

    # Show result
    st.success(f"üèÜ Predicted Winner: {prediction[0]}")



